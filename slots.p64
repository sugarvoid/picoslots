picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NC0yNCAxNDo0Njo1MyIscmV2aXNpb249MjMyNV1dbHo0AIQEAAAaNgAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIANt5PTAsem9vbT0xNX0sPwD-LBgT
wAMAAwAjgAMqAwADgBoAGgMAA1AaMAoDAANAGlAKAANACmAKEzAKYBpQClAKcApAGnAaIAqwKvAY
bAAe-ygSWAA4MBgwCA8YCCAIIAhQDjAIIAhADkAIIAigCCAYkAhACHAIUBhgCGAIUAiACCAYoAgA
GLAYagAg8gUHKbAZAAmwCSAJgHlwCVAZUAlwCQQA-weACUAJgAkwCRBpAAkwCQAJYBlAqfAiYQAe
-zMWQ6ADMANgIxAbEANAA0ALMAMwAwALgAMgAwAbUAsAAyADcBsAAzATgANQA0AjYAMACxADkAMA
GwADkAMwA6Az8AZzAB7wCiHK8AM3YBcgBxAHIBcQJxAHABcgFxAHAAcKAFEQJxAnEA4AYQAHEBcw
NwgAQicgFyAgAG8H8AO68BJzAB7gI5xADCAMEAwgHBAMQBwMAFEwDEAMMAIAEVAOABBgHgD-CAxw
DBAMEAyQDAAMAAywDBAMsCzQDPAIbwAe-z0HTxtwPjAuIC6ADiAOYEgQHjA4IAgQDiAoQBgOAA4Q
GFAYAA4ADgAYUBgQDgAOGEAoIA4ADggwKEAOEAgAOFAeEChwHhAuUD5AfvAF7AAf9wOoQAiACEB4
EAiwCAAIwAgACLAEAM_gGAAIoAgQCLAo8BlbABqPEhIE9gPwABYDABkv9gNjAAsZOGIAtAgIBPAD
FcAFGgUwBAArNRBBAHMtMC4xODc1RwAwMi42DQACrwAdNk0AdAsVQAUQBTAEAA9NACqcED8QMA4Q
HiAOAgBPEB4gPlkAJu8EBAQAGgAKEBoQCgAaAJABDB026wEf8F8BHEFmAAYFAgAjDxAJAM8MZgxm
DBYlFgBmAGaAAA0ZMk8A9wgKCgQgMTARPxAREAEOPw4OAQABDl0OEQQAABIArz0OARARPhEwMSDI
Ag0P3QAeDzEA-----------Qw0VABPA49S5gBfAsBQUAUED-HCJACABPDvAgDgkAKBH_RgAv8CwF
AFrwAQjG8AcFYAXgViAGoAYgVtAMAFEGEAoABhAAUgYAChAGFAAACgACFAAAHgACFAATOhIAHzok
AAgPTAAAB2wABIAALvAsBQDwEID_G3AFYAWwDvASDrAFYAWgDvAUDqAFYAWQDvAWDpAiAFAO8BgO
gAkAOfwagDwADwUADz71LjAbDDUyNTMCABM0BwKQNC43MDA0MzI5BgAiMzQVAhk0FQJgAwUEFxAH
AgAvACcqDBp-AwUEJxBHEDUAIACQDx83NwAdUAcAFwA3pwAPOQAdPzcQJ24AIG8QBxA3ADfcACAv
EAelABEPyQMrANYALwBHnwAfHzdCASRPABcAF24AHxEADgEPOAAfH_AxAHxxCwUEJwAnADQSEDC8
AgE2EgMOABAn5gAPYw8-DzEA--------------------------------------------WVBtPTh9
fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yNCAxNDo0Njo1MyJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NC0yNCAxNDo0Njo1MyIscmV2aXNpb249MjE2Nl1dbHo0AGsAAABbEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgA0nk9MCx0aWxlX2g9MTYKABB3CgCwem9vbT0wLjI1fX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yNCAxNDo0Njo1MyJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NC0yNCAxNDo0Njo1MyIscmV2aXNpb249MjE3Ml1dbHo0ACMBAAC0CgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA----
--_9H-8BAKzzDcgPQAAPEEAPJw--Dyn--y0ADQD9LQ4NDv0t8HAbAPUJMA8yDzQNDzcPNQ85-Skg
DSD9KS4NLv0pIQDxCDQPOQ81DzsPNw88Dz4PO-0ocP0ofv0oIADlCAACIA8q-S8A-S8M-S8zAIM5
-S8B-S8PEBMAcAog-bLwcAMbACD9sAkAHwQIABEU-wEAHHERAA8BAP-JUP----_4
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yNCAxNDo0Njo1MyJdXQ==
:: classic.lua
--[[pod_format="raw",created="2025-04-13 15:00:11",modified="2025-04-18 03:30:20",revision=110]]
--
-- classic
--
-- Copyright (c) 2014, rxi
--
-- This module is free software; you can redistribute it and/or modify it under
-- the terms of the MIT license. See LICENSE for details.
--


Object = {}
Object.__index = Object


function Object:new()
end


function Object:extend()
  local cls = {}
  for k, v in pairs(self) do
    if k:find("__") == 1 then
      cls[k] = v
    end
  end
  cls.__index = cls
  cls.super = self
  setmetatable(cls, self)
  return cls
end


function Object:implement(...)
  for _, cls in pairs({...}) do
    for k, v in pairs(cls) do
      if self[k] == nil and type(v) == "function" then
        self[k] = v
      end
    end
  end
end


function Object:is(T)
  local mt = getmetatable(self)
  while mt do
    if mt == T then
      return true
    end
    mt = getmetatable(mt)
  end
  return false
end


function Object:__tostring()
  return "Object"
end


function Object:__call(...)
  local obj = setmetatable({}, self)
  obj:new(...)
  return obj
end


:: clock.lua
--[[pod_format="raw",created="2025-04-20 14:09:58",modified="2025-04-24 14:46:53",revision=1333]]
Trigger = Object:extend()

function Trigger:new(callback, seconds, is_repeat)
    self.callback = nil
    self.sec = nil
    self.is_repeat = nil
end

-----------------------

Clock = Object:extend()

function Clock:new()
    self.seconds = 0
    self.t = 0
    self.is_running = false
    self.triggers = nil
end

function Clock:add_trigger(callback, seconds, is_repeat)
    local _trig = Trigger(callback, seconds, is_repeat)
    if self.triggers == nil then
        self.triggers = {}
    end
    table.insert(self.triggers, _trig)
end

function Clock:tick()
    self.seconds = self.seconds + 1
    self.t = 0
end

function Clock:update()
    if self.is_running then
        self.t = self.t + 1
        if self.t >= 60 then
            self:tick()
        end
    end
end

function Clock:stop()
	self:restart()
    self.is_running = false
end

function Clock:start()
    self.is_running = true
end

function Clock:restart()
    self.t = 0
    self.seconds = 0
end
:: coin.lua
--[[pod_format="raw",created="2025-04-22 00:25:21",modified="2025-04-24 14:46:53",revision=744]]

Coin = Object:extend()
all_coins = {}

function randi_rang(l, h)
    return flr(rnd(h - l + 1)) + l
end

function Coin:new(x, y)
	self.img = 13
	self.x = x
	self.y = y 
end

function Coin:draw()
	if self.y >= 74 then
		spr(self.img, self.x, self.y)
	end
end

function Coin:update()
	self.y += 0.5
	if self.y >= 95 then
		del(all_coins, self)
	end 
end

function draw_coins()
	foreach(all_coins, function(obj) obj:draw() end )
end

function update_coins()
	foreach(all_coins, function(obj) obj:update() end )
end

function spawn_coin(num)
	for i=1, num+1 do
		local x = randi_rang(30, 62)
		local y = 74 - randi_rang(2, 15)
		add(all_coins, Coin(x,y))
	end
end



:: face.lua
--[[pod_format="raw",created="2025-04-19 16:03:43",modified="2025-04-24 14:46:53",revision=2107]]
Face = Object:extend()

local FACE_STR = {
	{"lemon",10},
	{"heart",8},
	{"bell",9},
	{"clover",27},
	{"bar",10},
	{"dimond",28},
	{"melon",11},
	{"seven",8},
}


function Face:new(reel, img, y)
	self.parent = reel
	self.img = img
	self.top = reel.y - 60
	self.bottom = reel.y + 75 
	self.x = reel.x + 1
	self.y = y
	self.speed = 3
end

function Face:draw()
	if self.y >= 15 and self.y <= 45 then
		spr(self.img, self.x, self.y)
	end
end

function Face:update()
	self.y += self.speed
	if self.y >= self.bottom then
		self.y = self.top
	end
end

function get_face_string(num)
	return tostr(num), FACE_STR[num][2]
	--return FACE_STR[num][1], FACE_STR[num][2]
end
:: flux.lua
--[[pod_format="raw",created="2025-04-19 17:37:55",modified="2025-04-19 21:10:06",revision=216]]
--
-- flux
--
-- Copyright (c) 2016 rxi
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

local flux = { _version = "0.1.5" }
flux.__index = flux

flux.tweens = {}
flux.easing = { linear = function(p) return p end }

local easing = {
  quad    = "p * p",
  cubic   = "p * p * p",
  quart   = "p * p * p * p",
  quint   = "p * p * p * p * p",
  expo    = "2 ^ (10 * (p - 1))",
  sine    = "-math.cos(p * (math.pi * .5)) + 1",
  --circ    = "-(math.sqrt(1 - (p * p)) - 1)",
  back    = "p * p * (2.7 * p - 1.7)",
  elastic = "-(2^(10 * (p - 1)) * math.sin((p - 1.075) * (math.pi * 2) / .3))"
}

local makefunc = function(str, expr)
  local load = loadstring or load
  return load("return function(p) " .. str:gsub("%$e", expr) .. " end")()
end

for k, v in pairs(easing) do
  flux.easing[k .. "in"] = makefunc("return $e", v)
  flux.easing[k .. "out"] = makefunc([[
    p = 1 - p
    return 1 - ($e)
  ]], v)
  flux.easing[k .. "inout"] = makefunc([[
    p = p * 2
    if p < 1 then
      return .5 * ($e)
    else
      p = 2 - p
      return .5 * (1 - ($e)) + .5
    end
  ]], v)
end



local tween = {}
tween.__index = tween

local function makefsetter(field)
  return function(self, x)
    local mt = getmetatable(x)
    if type(x) ~= "function" and not (mt and mt.__call) then
      error("expected function or callable", 2)
    end
    local old = self[field]
    self[field] = old and function() old() x() end or x
    return self
  end
end

local function makesetter(field, checkfn, errmsg)
  return function(self, x)
    if checkfn and not checkfn(x) then
      error(errmsg:gsub("%$x", tostring(x)), 2)
    end
    self[field] = x
    return self
  end
end

tween.ease  = makesetter("_ease",
                         function(x) return flux.easing[x] end,
                         "bad easing type '$x'")
tween.delay = makesetter("_delay",
                         function(x) return type(x) == "number" end,
                         "bad delay time; expected number")
tween.onstart     = makefsetter("_onstart")
tween.onupdate    = makefsetter("_onupdate")
tween.oncomplete  = makefsetter("_oncomplete")


function tween.new(obj, dur, vars)
  local self = setmetatable({}, tween)
  self.obj = obj
  self.rate = dur > 0 and 1 / dur or 0
  self.progress = dur > 0 and 0 or 1
  self._delay = 0
  self._ease = "quadout"
  self.vars = {}
  for k, v in pairs(vars) do
    if type(v) ~= "number" then
      error("bad value for key '" .. k .. "'; expected number")
    end
    self.vars[k] = v
  end
  return self
end


function tween:init()
  for k, v in pairs(self.vars) do
    local x = self.obj[k]
    if type(x) ~= "number" then
      error("bad value on object key '" .. k .. "'; expected number")
    end
    self.vars[k] = { start = x, diff = v - x }
  end
  self.inited = true
end


function tween:after(...)
  local t
  if select("#", ...) == 2 then
    t = tween.new(self.obj, ...)
  else
    t = tween.new(...)
  end
  t.parent = self.parent
  self:oncomplete(function() flux.f_add(self.parent, t) end)
  return t
end


function tween:stop()
  flux.remove(self.parent, self)
end



function flux.group()
  return setmetatable({}, flux)
end


function flux:to(obj, dur, vars)
  return flux.f_add(self, tween.new(obj, dur, vars))
end


function flux:update(deltatime)
  for i = #self, 1, -1 do
    local t = self[i]
    if t._delay > 0 then
      t._delay = t._delay - deltatime
    else
      if not t.inited then
        flux.clear(self, t.obj, t.vars)
        t:init()
      end
      if t._onstart then
        t._onstart()
        t._onstart = nil
      end
      t.progress = t.progress + t.rate * deltatime
      local p = t.progress
      local x = p >= 1 and 1 or flux.easing[t._ease](p)
      for k, v in pairs(t.vars) do
        t.obj[k] = v.start + x * v.diff
      end
      if t._onupdate then t._onupdate() end
      if p >= 1 then
        flux.remove(self, i)
        if t._oncomplete then t._oncomplete() end
      end
    end
  end
end


function flux:clear(obj, vars)
  for t in pairs(self[obj]) do
    if t.inited then
      for k in pairs(vars) do t.vars[k] = nil end
    end
  end
end


function flux:f_add(tween)
  -- Add to object table, create table if it does not exist
  local obj = tween.obj
  self[obj] = self[obj] or {}
  self[obj][tween] = true
  -- Add to array
  table.insert(self, tween)
  tween.parent = self
  return tween
end


function flux:remove(x)
  if type(x) == "number" then
    -- Remove from object table, destroy table if it is empty
    local obj = self[x].obj
    self[obj][self[x]] = nil
    if not next(self[obj]) then self[obj] = nil end
    -- Remove from array
    self[x] = self[#self]
    return table.remove(self)
  end
  for i, v in ipairs(self) do
    if v == x then
      return flux.remove(self, i)
    end
  end
end


function get_flux()
	local your_flux = {
	  to      = function(...) return flux.to(flux.tweens, ...) end,
	  update  = function(...) return flux.update(flux.tweens, ...) end,
	  remove  = function(...) return flux.remove(flux.tweens, ...) end,
	}
	setmetatable(your_flux, flux)
	return your_flux

end


:: handle.lua
--[[pod_format="raw",created="2025-04-19 17:45:36",modified="2025-04-24 14:46:53",revision=1867]]

handle = {
	x=78,
	y=30,
	radius = 4,
	draw=function(self)
		rect(self.x+4, self.y+5, self.x+5, 55, 13)
		pal(14,0)
		spr(16, self.x, self.y)
		pal()
	end,
	update=function(self)
	end,
	pull=function(self)
		
		if self.y == 30 then
			cash = mid(0, cash - curr_bet, 999999)
			flux.to(self, 0.6, { y = 70}):ease("quadin"):oncomplete(
				function()
					start_reels()
					flux.to(self, 1, {y = 30}):ease("backin")
				end
			)
		end
	end,
}
:: hud.lua
--[[pod_format="raw",created="2025-04-23 15:40:59",modified="2025-04-24 14:46:53",revision=348]]

p_spr_1 = 75
p_spr_2 = 75
p_spr_3 = 75
p_spr_4 = 75



hud = {
	draw=function(self)
		print("$", 32, 1, 7)
		print(pad_zeros(cash, 6), 38, 2, 7)
		if show_payout then
			spr(p_spr_1, 42, 31)
			spr(p_spr_2, 42+4, 31)
			spr(p_spr_3, 42+8, 31)
			spr(p_spr_4, 42+8+4, 31)
		end
		if auto_mode and flr(time() * 2) % 2 == 0  then
			print("AUTO", 1, 92, 7)
		end
	end,
	update_payout_spr=function(self,num)
		p_spr_1, p_spr_2, p_spr_3, p_spr_4 = number_to_spr(num)
	end,
}

local sprite_map = {
    ["0"] = 75,
    ["1"] = 65,
    ["2"] = 66,
    ["3"] = 67,
    ["4"] = 68,
    ["5"] = 69,
    ["6"] = 70,
    ["7"] = 71,
    ["8"] = 73,
    ["9"] = 74
}


function number_to_spr(num)
	local s1,s2,s3,s4 = nil,nil,nil,nil
	
	local char_array = split_num(num)
	
	s1 = sprite_map[char_array[1]] or 75
	s2 = sprite_map[char_array[2]] or 75
	s3 = sprite_map[char_array[3]] or 75
	s4 = sprite_map[char_array[4]] or 75

	return s1,s2,s3,s4
end

function split_num(num_str) 
	num_str = tostr(pad_zeros(num_str, 4))
	local chars = {}
	for c in num_str:gmatch(".") do
		table.insert(chars, c)
	end
	return chars
end
:: light.lua
--[[pod_format="raw",created="2025-04-21 23:26:22",modified="2025-04-24 14:46:53",revision=906]]

Light = Object:extend()

local light_y = 17

function Light:new(x)
	self.img = 11
	self.tic = 0
	self.x = x
	self.is_on = false 
	self.col = 8
end

function Light:draw()
	pal(30, self.col)
	spr(self.img, self.x, light_y)
	pal()
end

function Light:update()
	if self.is_on then
		self.tic += 1
		if self.tic == 10 then
			self:turn_off()
		end
	end
end

function Light:turn_on()
	self.is_on = true
	self.img = 10
end

function Light:turn_off()
	self.is_on = false
	self.img = 11
	self.tic = 0
end

function draw_lights()
	foreach(all_lights, function(obj) obj:draw() end )
end

function update_lights()
	foreach(all_lights, function(obj) obj:update() end )
end

local light_small_actions = {
	[1] = function()
		all_lights[4]:turn_on()
	end,
	[2] = function()
		all_lights[3]:turn_on()
		all_lights[5]:turn_on()
	end,
	[3] = function()
		all_lights[2]:turn_on()
		all_lights[6]:turn_on()
	end,
	[4] = function()
		all_lights[1]:turn_on()
		all_lights[7]:turn_on()
	end,
	[5] = function()
		all_lights[2]:turn_on()
		all_lights[6]:turn_on()
	end,
	[6] = function()
		all_lights[3]:turn_on()
		all_lights[5]:turn_on()
	end,
	[7] = function()
		all_lights[4]:turn_on()
	end,
	[9] = function()
		light_man:restart()
	end,
}

light_man = {
	is_running=false,
	t=0,
	seconds=0,
	update=function(self)
		if self.is_running then
	        self.t = self.t + 1
	        if self.t >= 5 then
	            --self:tick()
	            self.seconds+=1
	            do_small_lights()
	            self.t = 0
	        end
	    end
	end,
	restart=function(self)
		self.is_running=false
		self.t=0
		self.seconds=0
	end,
}



function do_small_lights()
	local action = light_small_actions[light_man.seconds]
	if action then
		action()
	end
end

all_lights = {
	Light(21),
	Light(29),
	Light(37),
	Light(45),
	Light(53),
	Light(61),
	Light(69),
}

:: main.lua
--[[pod_format="raw",created="2025-04-19 14:51:36",icon=userdata("u8",16,16,"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),lowcol_icon=false,modified="2025-04-24 14:46:53",revision=3099]]

include "flux.lua"
include "classic.lua"
include "clock.lua"
include "light.lua"
include "coin.lua"
include "face.lua"
include "reel.lua"
include "handle.lua"
include "hud.lua"

flux = get_flux()

local W, H = 100, 100

local last_time = time()
local dt = 0
local key_delay = 0

local clock_pull = Clock()
local clock_stop_1 = Clock()
local clock_stop_2 = Clock()
local clock_stop_3 = Clock()

local clocks = {}
add(clocks, clock_pull)
add(clocks, clock_stop_1)
add(clocks, clock_stop_2)
add(clocks, clock_stop_3)

local results = {0,0,0}

local PAYOUTS_3 = {
	100,200,300,400,500,600,700,800
}

local PAYOUTS_2 = {
	10,20,30,40,50,60,70,80
}

auto_mode = false
has_spun = false
show_payout = false
cash = 200
payout = 0
curr_bet = 5
reels = {}

local canvas = userdata("u8", W, H)

function _init()
	poke(0x5f5c, 20)
	poke(0x5f5d, 20)
	window {
		width      = 100,
		height     = 100,
		resizeable = false,
		title      = "Slots",
		fullscreen = false,
		x = 260,
		y = 50,
		--icon=get_spr(15)
	}
	
	reel_1 = Reel(20, 40)
	reel_2 = Reel(40, 40)
	reel_3 = Reel(60, 40)
	
	add(reels, reel_1)
	add(reels, reel_2)
	add(reels, reel_3)
	
	toggle_window_size()
end

function _update()
	if not auto_mode then
		if btnp(3) and not are_reels_spinning() and cash >= curr_bet then
			pull_handle()
		end
	end
	
	if _keyp("a") then
		toggle_auto_mode()
	elseif _keyp("f") then
		toggle_window_size()
	end
	
	if btnp(1) and not are_reels_spinning() then
		curr_bet = mid(5, curr_bet + 5, 80)
	elseif btnp(0) and not are_reels_spinning() then
		curr_bet = mid(5, curr_bet - 5, 80)
	end
	
	if btnp(4) then
		all_lights[2]:turn_on()
	end

	update_dt()
  	flux.update(dt)
  	update_coins()
  	update_lights()
  	light_man:update()

	foreach(reels, function(obj) obj:update() end )
	foreach(clocks, function(obj) obj:update() end )
	
	if clock_pull.seconds >= 5 then
		clock_pull.seconds = 0
		pull_handle()
	end
	
	if clock_stop_1.seconds == 2 then
		clock_stop_1:stop()
		stop_reel(1)
	end
	if clock_stop_2.seconds == 3 then
		clock_stop_2:stop()
		stop_reel(2)
	end
	if clock_stop_3.seconds == 4 then
		clock_stop_3:stop()
		stop_reel(3)
	end
end

function _draw()
	cls()
	set_draw_target(canvas)
	cls()
	
	line(0, 80, 17, 80 , 4)
	line(80, 80, 100, 80 , 4)
	
	spr(64, 15, 25)
	draw_lights()
	draw_coins()
	
	clip(20, 40, 58, 18)
	reel_1:draw()
	reel_2:draw()
	reel_3:draw()
	clip()
	
	spr(12, 78, 52)

	handle:draw()
	
	print(pad_zeros(curr_bet, 2), 45, 61, 7)
	
 	--print("mem: " .. stat(0) .. "kb", 10, 0, 8)
   --print("cpu: " .. stat(1) * 100 .. "%", 10, 8, 8)
	
	hud:draw()
	set_draw_target()
	
	sspr(canvas, 0, 0, 100, 100, 0, 0, W, H)
end

function start_reels()
	sfx(3, 2)
	results = {0,0,0}
	payout = 0
	show_payout = false
	has_spun = true
	foreach(reels, function(obj) obj:spin() end ) 
end

function stop_reel(num)
	if num == 1 then
		reel_1:stop()
		results[1] = reel_1.face
	elseif num == 2 then
		reel_2:stop()
		results[2] = reel_2.face
	elseif num == 3 then
		reel_3:stop()
		results[3] = reel_3.face
	end
	if not are_reels_spinning() and has_spun then
		sfx(-1,2)
		has_spun = false
		show_payout = true
		payout = get_payout(results)
		payout = payout * (curr_bet/5)
		hud:update_payout_spr(payout)
		cash = mid(0, cash + payout, 999999)
	end
end

function update_dt()
	local t = time()
  	dt = t - last_time
  	last_time = t
end

function pad_zeros(num, zeros)
	return string.format("%0".. zeros .. "d", num)
end

function toggle_auto_mode()
	auto_mode = not auto_mode
	if auto_mode then
		if not are_reels_spinning() then
			pull_handle()
		else
			start_reel_clocks()
		end
		clock_pull:start()
	else
		clock_pull:stop()
	end
end

function are_reels_spinning()
	return reel_1.spinning or reel_2.spinning or reel_3.spinning
end

function pull_handle()
	handle:pull()
	start_reel_clocks()
end

function start_reel_clocks()
	clock_stop_1:start()
	clock_stop_2:start()
	clock_stop_3:start()
end

function _keyp(k)
    if keyp(k) and key_delay <= 0 then
        key_delay = 20
        return true
    else
        key_delay = mid(0, key_delay - 1, 21)
    end
end

function get_payout(r)
	--TODO: Figure out better payout math
	if r[1] == 0 or r[2] == 0 or r[3] == 0 then
		return 0
	end
	if r[1] == r [2] and r[2] == r[3] then
		sfx(2)
		light_man.is_running=true
		spawn_coin(10)
		return PAYOUTS_3[r[1]]
	elseif r[1] == r[2] or r[2] == r[3] or r[1] == r[3] then
		local match = r[1] == r[2] and r[1] or r[2] == r[3] and r[2] or r[1]
		sfx(1)
		light_man.is_running=true
		spawn_coin(10)
		return PAYOUTS_2[match] or 0
	else
		sfx(0)
		return 0
	end
end

function update_player_cash()
	store("slots_cash.pod", cash)
end

function update_title(num)
	window{title="$" .. pad_zeros(num, 6)}
end

function toggle_window_size()
	--todo: both will always be the same, do i need both varibles?
	if W == 100 then
		W, H = 200,200
	else
		W,H=100,100
	end
	window {
		width      = W,
		height     = H
		}
end



:: reel.lua
--[[pod_format="raw",created="2025-04-19 16:25:05",modified="2025-04-24 14:46:53",revision=2054]]

Reel = Object:extend()

local bg_spr = 9

function Reel:new(x, y)
	self.img = 1
	self.x = x
	self.y = y
	self.reel_y = 0 
	self.faces = {}
	set_upfaces(self)
	self.spinning = false
	self.face = 3 
end

function Reel:stop()
	if self.spinning then
		sfx(4)
		self.spinning = false
		self.face = flr(rnd(8)) + 1 
	end
end

function Reel:update()
	if self.spinning then
		for f in all(self.faces) do 
			f:update()
		end
	end
end

function Reel:draw()
	if not self.spinning then
		spr(self.face, self.x+1, self.y+1)
	else
		for f in all(self.faces) do 
			f:draw()
		end
	end
	
	spr(bg_spr, self.x, self.y)
end

function set_upfaces(reel)
	local start_y = reel.y +1
	for i=1, 8 do
		local f = Face(reel, i, start_y -(i - 1) * 16)
		add(reel.faces, f)
	end
end

function Reel:spin()
	self.spinning = true
end
:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9InN1Z2Fydm9pZCIsYmJzX2lkPSJfZGV2MjY3NiIsY3JlYXRlZD0i
MjAyNS0wNC0xOSAxNDo1MjoxNyIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQw
ZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwZDBk
MGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAxMDcwNzA2MDYwNjA2MDYwNjA2MDYwNjA3MDcwNzAx
MDEwNzA3MDYwNjA2MDYwNjA2MDYwNjA2MDcwNzA2MDEwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIpLGxvd2NvbF9p
Y29uPXRydWUsbW9kaWZpZWQ9IjIwMjUtMDQtMjQgMTQ6NDY6NTMiLG5vdGVzPSIiLHJ1bnRpbWU9
MTcsc2FuZGJveD1mYWxzZSx0aXRsZT0iU2xvdHMiLHZlcnNpb249IiIsd29ya3NwYWNlcz17e2xv
Y2F0aW9uPSJtYWluLmx1YSMyNzkiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InJlZWwu
bHVhIzU0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJmYWNlLmx1YSMxNSIsd29ya3Nw
YWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ibGlnaHQubHVhIzExMCIsd29ya3NwYWNlX2luZGV4PTF9
LHtsb2NhdGlvbj0iY29pbi5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iaGFu
ZGxlLmx1YSMxNyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iY2xvY2subHVhIzEiLHdv
cmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Imh1ZC5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9
LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAv
MC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNl
X2luZGV4PTR9fV1d
:: [eoc]
