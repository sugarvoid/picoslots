picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NS0wMyAwMTozNTowMSIscmV2aXNpb249MzI0NV1dbHo0ANYEAAC6NgAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMt5PTAsem9vbT05fSw_APIYJj8f
kB4wHmAOcA5ADpAOMA6QDiAOsA4QDg8UCI8bCA4gbxQPGz8UFABvsA4gvvASYwAd5CM4EDhAGCAY
IBgwCJAIBAD-CUAIcAhgCFAIcAhQCIAIMAigCBAIwBjwF14AHfcEBjmgCTAJgAlQCWAJcAlACZAJ
MAQAVCAJsAkQBABv2fAHOfAGYQAd8wITMwAzUAMgAwADIANAAzADMAYA11ADYBNgEyATcANgA1AY
AP8GQAMgAw8bAyADUCMADgAjoA7gHvAHdQAd5SHa8AMnEBcABwAHQAcAAgAiQCcIAAAWABAgCADP
J0AHIBcQJ-AE2vAxZAAd8BAECxALsAsgC3AbAAsgC4AbAAsAG7AbDxmQGw4gDnAbEAIQHvgBgCAO
sB4QDsAOBACPAA7QLuAe8AFsAB3xHRhDoAMAAwATcCMwA2ADEAOAHxgDDhADcA4AAxAOAANwDjAO
EANgDjAuAw5QDABTAA5QTjCRAm8wDqA_8AVzAB0wE4hgXQKDeAAIsAgQCKAEADGwCAAEABfACABP
wCjwGF4AGY8SEgT2A-AAFgMAGS-2A2IACxk4YgC0CAgE8AMVwAUaBTAEACs1EEEAcy0wLjE4NzVH
ADAyLjYNAAFMAC0xNk0AdAsVQAUQBTAEAA9NACqcED8QMA4QHiAOAgBPEB4gPlkAJu8EBAQAGgAK
EBoQCgAaAC0BCy0xNu4BH-BfARxBZgAGBQIAIw8QCQDPDGYMZgwWJRYAZgBmgAANGTJPAPcICgoE
IDEwET8QERABDj8ODgEAAQ5dDhEEAAASAK89DgEQET4RMDEgXQAMHzXdAB0vMTC1BBYiQBO1BAAG
AB9AtQQCPjMOM7MED3QAEvATKV8bMD4AHgAfEkAeHR4tEA0gHg0QHRANEA1ADRAdIB1gHQ4AI3AN
BgD-AA0AHZAdIA2wDRANwB3wFW8ADQ_-BFgPbQAAH-AyAH6PAwUEMAcAVyD4AgwPNAAuDpoADzEA
-wKPAwUEIFcABzA0ACEPygAeDzEA------_rw0VABPA49S5gBfAsBQUAUED-ECJACABPDvAgDgkA
KBH_RgAv8CwFAFpBCMbwBwgAPwagBgoAMANOAB4sBQDwEID1G3AFYAWwDvASDrAFYAWgDvAUDqAF
YAWQDvAWDpAiAFAO8BgOgAkAOf4agDwADwUADyz1LoQHczEuMjQ5MjQCAAPTAaAxOC44ODkzMjE3
BgAfMtMHBDAXEAcCAC8AJ8MMGn8DBQQnEEcQNQAgXwcAFxA3NwAdUAcAFwA3pwAPOQAdPzcQJ24A
IG8QBxA3ADfcACAvEAelABEPlQMrANYALwBHnwAfHzdCASRPABcAF24AHxEADgEPOAAfH_AxAHyA
CwUEJwAnADfEEhAwvAIRF8gSAg4AECfmAA-8DxvRBwcEdkAWEAsQFgArAAgAL0B2-gEZAEAAkUoW
GgsaFgorCggAH0pAAB6fQBZAFgAoABZAfAAifkoWCigKFkp4AA98Bg8PMQD-----------------
-------------------------7NQbT04fX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NS0wMyAwMTozNTowMiJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NS0wMyAwMTozNTowMSIscmV2aXNpb249MzAzOV1dbHo0AGsAAABbEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgA0nk9MCx0aWxlX2g9MTYKABB3CgCwem9vbT0wLjI1fX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NS0wMyAwMTozNTowMiJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NS0wMyAwMTozNTowMSIscmV2aXNpb249MzA1M11dbHo0ACwBAADQCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA----
--_9H-8BAKzzDcgPQAAPEEAPJw--Dyn--y0ADQD9LQ4NDv0t8HAbAPUJMA8yDzQNDzcPNQ85-Skg
DSD9KS4NLv0pIQDxCDQPOQ81DzsPNw88Dz4PO-0ocP0ofv0oIADlCAACIA8q-S8A-S8M-S8zAIM5
-S8B-S8PEBMA9AQKIC0POQ9AD0MPL-0sMP0sPv0rKwAv-bAKACAU-wEAHnETAA8BAP-JUP----_4
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NS0wMyAwMTozNTowMiJdXQ==
:: classic.lua
--[[pod_format="raw",created="2025-04-13 15:00:11",modified="2025-05-01 15:59:41",revision=137]]
--
-- classic
--
-- Copyright (c) 2014, rxi
--
-- This module is free software; you can redistribute it and/or modify it under
-- the terms of the MIT license. See LICENSE for details.
--


Object = {}
Object.__index = Object


function Object:new()
end


function Object:extend()
  local cls = {}
  for k, v in pairs(self) do
    if k:find("__") == 1 then
      cls[k] = v
    end
  end
  cls.__index = cls
  cls.super = self
  setmetatable(cls, self)
  return cls
end


function Object:implement(...)
  for _, cls in pairs({...}) do
    for k, v in pairs(cls) do
      if self[k] == nil and type(v) == "function" then
        self[k] = v
      end
    end
  end
end


function Object:is(T)
  local mt = getmetatable(self)
  while mt do
    if mt == T then
      return true
    end
    mt = getmetatable(mt)
  end
  return false
end


function Object:__tostring()
  return "Object"
end


function Object:__call(...)
  local obj = setmetatable({}, self)
  obj:new(...)
  return obj
end


:: clock.lua
--[[pod_format="raw",created="2025-04-20 14:09:58",modified="2025-05-01 15:59:41",revision=1927]]
Trigger = Object:extend()

function Trigger:new(callback, seconds, is_repeat)
    self.callback = nil
    self.sec = nil
    self.is_repeat = nil
end

-----------------------

Clock = Object:extend()

function Clock:new()
    self.seconds = 0
    self.t = 0
    self.is_running = false
    self.triggers = nil
end

function Clock:add_trigger(callback, seconds, is_repeat)
    local _trig = Trigger(callback, seconds, is_repeat)
    if self.triggers == nil then
        self.triggers = {}
    end
    table.insert(self.triggers, _trig)
end

function Clock:tick()
    self.seconds = self.seconds + 1
    self.t = 0
end

function Clock:update()
    if self.is_running then
        self.t = self.t + 1
        if self.t >= 60 then
            self:tick()
        end
    end
end

function Clock:stop()
	self:restart()
    self.is_running = false
end

function Clock:start()
    self.is_running = true
end

function Clock:restart()
    self.t = 0
    self.seconds = 0
end
:: coin.lua
--[[pod_format="raw",created="2025-04-22 00:25:21",modified="2025-05-01 15:59:41",revision=1340]]

Coin = Object:extend()
all_coins = {}

function randi_rang(l, h)
    return flr(rnd(h - l + 1)) + l
end

function Coin:new(x, y)
	self.img = 13
	self.x = x
	self.y = y 
end

function Coin:draw()
	if self.y >= 74 then
		spr(self.img, self.x, self.y)
	end
end

function Coin:update()
	self.y += 0.5
	if self.y >= 95 then
		del(all_coins, self)
	end 
end

function draw_coins()
	foreach(all_coins, function(obj) obj:draw() end )
end

function update_coins()
	foreach(all_coins, function(obj) obj:update() end )
end

function spawn_coin(num)
	for i=1, num+1 do
		local x = randi_rang(30, 62)
		local y = 74 - randi_rang(2, 15)
		add(all_coins, Coin(x,y))
	end
end



:: face.lua
--[[pod_format="raw",created="2025-04-19 16:03:43",modified="2025-05-01 15:59:41",revision=2700]]
Face = Object:extend()

local FACE_STR = {
	{"lemon",10},
	{"heart",8},
	{"bell",9},
	{"clover",27},
	{"bar",10},
	{"dimond",28},
	{"melon",11},
	{"seven",8},
}


function Face:new(reel, img, y)
	self.parent = reel
	self.img = img
	self.top = reel.y - 60
	self.bottom = reel.y + 75 
	self.x = reel.x + 1
	self.y = y
	self.speed = 3
end

function Face:draw()
	if self.y >= 15 and self.y <= 45 then
		spr(self.img, self.x, self.y)
	end
end

function Face:update()
	self.y += self.speed
	if self.y >= self.bottom then
		self.y = self.top
	end
end

function get_face_string(num)
	return tostr(num), FACE_STR[num][2]
	--return FACE_STR[num][1], FACE_STR[num][2]
end
:: flux.lua
--[[pod_format="raw",created="2025-04-19 17:37:55",modified="2025-05-01 15:59:41",revision=247]]
--
-- flux
--
-- Copyright (c) 2016 rxi
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

local flux = { _version = "0.1.5" }
flux.__index = flux

flux.tweens = {}
flux.easing = { linear = function(p) return p end }

local easing = {
  quad    = "p * p",
  cubic   = "p * p * p",
  quart   = "p * p * p * p",
  quint   = "p * p * p * p * p",
  expo    = "2 ^ (10 * (p - 1))",
  sine    = "-math.cos(p * (math.pi * .5)) + 1",
  --circ    = "-(math.sqrt(1 - (p * p)) - 1)",
  back    = "p * p * (2.7 * p - 1.7)",
  elastic = "-(2^(10 * (p - 1)) * math.sin((p - 1.075) * (math.pi * 2) / .3))"
}

local makefunc = function(str, expr)
  local load = loadstring or load
  return load("return function(p) " .. str:gsub("%$e", expr) .. " end")()
end

for k, v in pairs(easing) do
  flux.easing[k .. "in"] = makefunc("return $e", v)
  flux.easing[k .. "out"] = makefunc([[
    p = 1 - p
    return 1 - ($e)
  ]], v)
  flux.easing[k .. "inout"] = makefunc([[
    p = p * 2
    if p < 1 then
      return .5 * ($e)
    else
      p = 2 - p
      return .5 * (1 - ($e)) + .5
    end
  ]], v)
end



local tween = {}
tween.__index = tween

local function makefsetter(field)
  return function(self, x)
    local mt = getmetatable(x)
    if type(x) ~= "function" and not (mt and mt.__call) then
      error("expected function or callable", 2)
    end
    local old = self[field]
    self[field] = old and function() old() x() end or x
    return self
  end
end

local function makesetter(field, checkfn, errmsg)
  return function(self, x)
    if checkfn and not checkfn(x) then
      error(errmsg:gsub("%$x", tostring(x)), 2)
    end
    self[field] = x
    return self
  end
end

tween.ease  = makesetter("_ease",
                         function(x) return flux.easing[x] end,
                         "bad easing type '$x'")
tween.delay = makesetter("_delay",
                         function(x) return type(x) == "number" end,
                         "bad delay time; expected number")
tween.onstart     = makefsetter("_onstart")
tween.onupdate    = makefsetter("_onupdate")
tween.oncomplete  = makefsetter("_oncomplete")


function tween.new(obj, dur, vars)
  local self = setmetatable({}, tween)
  self.obj = obj
  self.rate = dur > 0 and 1 / dur or 0
  self.progress = dur > 0 and 0 or 1
  self._delay = 0
  self._ease = "quadout"
  self.vars = {}
  for k, v in pairs(vars) do
    if type(v) ~= "number" then
      error("bad value for key '" .. k .. "'; expected number")
    end
    self.vars[k] = v
  end
  return self
end


function tween:init()
  for k, v in pairs(self.vars) do
    local x = self.obj[k]
    if type(x) ~= "number" then
      error("bad value on object key '" .. k .. "'; expected number")
    end
    self.vars[k] = { start = x, diff = v - x }
  end
  self.inited = true
end


function tween:after(...)
  local t
  if select("#", ...) == 2 then
    t = tween.new(self.obj, ...)
  else
    t = tween.new(...)
  end
  t.parent = self.parent
  self:oncomplete(function() flux.f_add(self.parent, t) end)
  return t
end


function tween:stop()
  flux.remove(self.parent, self)
end



function flux.group()
  return setmetatable({}, flux)
end


function flux:to(obj, dur, vars)
  return flux.f_add(self, tween.new(obj, dur, vars))
end


function flux:update(deltatime)
  for i = #self, 1, -1 do
    local t = self[i]
    if t._delay > 0 then
      t._delay = t._delay - deltatime
    else
      if not t.inited then
        flux.clear(self, t.obj, t.vars)
        t:init()
      end
      if t._onstart then
        t._onstart()
        t._onstart = nil
      end
      t.progress = t.progress + t.rate * deltatime
      local p = t.progress
      local x = p >= 1 and 1 or flux.easing[t._ease](p)
      for k, v in pairs(t.vars) do
        t.obj[k] = v.start + x * v.diff
      end
      if t._onupdate then t._onupdate() end
      if p >= 1 then
        flux.remove(self, i)
        if t._oncomplete then t._oncomplete() end
      end
    end
  end
end


function flux:clear(obj, vars)
  for t in pairs(self[obj]) do
    if t.inited then
      for k in pairs(vars) do t.vars[k] = nil end
    end
  end
end


function flux:f_add(tween)
  -- Add to object table, create table if it does not exist
  local obj = tween.obj
  self[obj] = self[obj] or {}
  self[obj][tween] = true
  -- Add to array
  table.insert(self, tween)
  tween.parent = self
  return tween
end


function flux:remove(x)
  if type(x) == "number" then
    -- Remove from object table, destroy table if it is empty
    local obj = self[x].obj
    self[obj][self[x]] = nil
    if not next(self[obj]) then self[obj] = nil end
    -- Remove from array
    self[x] = self[#self]
    return table.remove(self)
  end
  for i, v in ipairs(self) do
    if v == x then
      return flux.remove(self, i)
    end
  end
end


function get_flux()
	local your_flux = {
	  to      = function(...) return flux.to(flux.tweens, ...) end,
	  update  = function(...) return flux.update(flux.tweens, ...) end,
	  remove  = function(...) return flux.remove(flux.tweens, ...) end,
	}
	setmetatable(your_flux, flux)
	return your_flux

end


:: handle.lua
--[[pod_format="raw",created="2025-04-19 17:45:36",modified="2025-05-01 15:59:41",revision=2475]]

handle = {
	x=78,
	y=30,
	radius = 4,
	draw=function(self)
		rect(self.x+4, self.y+5, self.x+5, 55, 6)
		pal(14,0)
		spr(16, self.x, self.y)
		pal()
	end,
	update=function(self)
	end,
	pull=function(self)
		
		if self.y == 30 then
			player_stats.total_pulls+=1
			player_stats.cash = mid(0, player_stats.cash - curr_bet, 999999)
			player_stats.total_spent += curr_bet
			flux.to(self, 0.6, { y = 70}):ease("quadin"):oncomplete(
				function()
					start_reels()
					flux.to(self, 1, {y = 30}):ease("backin")
				end
			)
		end
	end,
}
:: hud.lua
--[[pod_format="raw",created="2025-04-23 15:40:59",modified="2025-05-03 01:35:01",revision=1170]]

p_spr_1 = 75
p_spr_2 = 75
p_spr_3 = 75
p_spr_4 = 75



hud = {
	draw=function(self)
		print("$", 32, 0, 7)
		print("\014" .. pad_zeros(player_stats.cash, 6), 38, 2, 7)
		if show_payout then
			spr(p_spr_1, 42, 31)
			spr(p_spr_2, 42+4, 31)
			spr(p_spr_3, 42+8, 31)
			spr(p_spr_4, 42+8+4, 31)
		end
		spr(81,58,61)
		spr(83,34,61)
		
		if btnp(1) then
			spr(84,58,61)
		end
		
		if btnp(0) then
			spr(82,34,61)
		end
		if auto_mode and flr(time() * 2) % 2 == 0  then
			print("AUTO", 1, 92, 7)
		end
	end,
	update_payout_spr=function(self,num)
		p_spr_1, p_spr_2, p_spr_3, p_spr_4 = number_to_spr(num)
	end,
}

local sprite_map = {
    ["0"] = 75,
    ["1"] = 65,
    ["2"] = 66,
    ["3"] = 67,
    ["4"] = 68,
    ["5"] = 69,
    ["6"] = 70,
    ["7"] = 71,
    ["8"] = 73,
    ["9"] = 74
}


function number_to_spr(num)
	local s1,s2,s3,s4 = nil,nil,nil,nil
	
	local char_array = split_num(num)
	
	s1 = sprite_map[char_array[1]] or 75
	s2 = sprite_map[char_array[2]] or 75
	s3 = sprite_map[char_array[3]] or 75
	s4 = sprite_map[char_array[4]] or 75

	return s1,s2,s3,s4
end

function split_num(num_str) 
	num_str = tostr(pad_zeros(num_str, 4))
	local chars = {}
	for c in num_str:gmatch(".") do
		table.insert(chars, c)
	end
	return chars
end
:: light.lua
--[[pod_format="raw",created="2025-04-21 23:26:22",modified="2025-05-01 15:59:41",revision=1500]]

Light = Object:extend()

local light_y = 17

function Light:new(x)
	self.img = 11
	self.tic = 0
	self.x = x
	self.is_on = false 
	self.col = 8
end

function Light:draw()
	pal(30, self.col)
	spr(self.img, self.x, light_y)
	pal()
end

function Light:update()
	if self.is_on then
		self.tic += 1
		if self.tic == 10 then
			self:turn_off()
		end
	end
end

function Light:turn_on()
	self.is_on = true
	self.img = 10
end

function Light:turn_off()
	self.is_on = false
	self.img = 11
	self.tic = 0
end

function draw_lights()
	foreach(all_lights, function(obj) obj:draw() end )
end

function update_lights()
	foreach(all_lights, function(obj) obj:update() end )
end

local light_small_actions = {
	[1] = function()
		all_lights[4]:turn_on()
	end,
	[2] = function()
		all_lights[3]:turn_on()
		all_lights[5]:turn_on()
	end,
	[3] = function()
		all_lights[2]:turn_on()
		all_lights[6]:turn_on()
	end,
	[4] = function()
		all_lights[1]:turn_on()
		all_lights[7]:turn_on()
	end,
	[5] = function()
		all_lights[2]:turn_on()
		all_lights[6]:turn_on()
	end,
	[6] = function()
		all_lights[3]:turn_on()
		all_lights[5]:turn_on()
	end,
	[7] = function()
		all_lights[4]:turn_on()
	end,
	[9] = function()
		light_man:restart()
	end,
}

light_man = {
	is_running=false,
	t=0,
	seconds=0,
	update=function(self)
		if self.is_running then
	        self.t = self.t + 1
	        if self.t >= 5 then
	            --self:tick()
	            self.seconds+=1
	            do_small_lights()
	            self.t = 0
	        end
	    end
	end,
	restart=function(self)
		self.is_running=false
		self.t=0
		self.seconds=0
	end,
}



function do_small_lights()
	local action = light_small_actions[light_man.seconds]
	if action then
		action()
	end
end

all_lights = {
	Light(21),
	Light(29),
	Light(37),
	Light(45),
	Light(53),
	Light(61),
	Light(69),
}

:: main.lua
--[[pod_format="raw",created="2025-04-19 14:51:36",icon=userdata("u8",16,16,"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),lowcol_icon=false,modified="2025-05-03 01:35:01",revision=4235]]



cd("/projects/picoslots")

include ("src/flux.lua")
include ("src/classic.lua")
include ("src/clock.lua")
include ("src/light.lua")
include ("src/coin.lua")
include ("src/face.lua")
include ("src/reel.lua")
include ("src/handle.lua")
include ("src/hud.lua")
include ("src/bank.lua")
include ("src/tab.lua")
include ("src/stats.lua")

include ("src/game.lua")

:: reel.lua
--[[pod_format="raw",created="2025-04-19 16:25:05",modified="2025-05-01 15:59:41",revision=2649]]

Reel = Object:extend()

local bg_spr = 9

function Reel:new(x, y)
	self.img = 1
	self.x = x
	self.y = y
	self.reel_y = 0 
	self.faces = {}
	set_upfaces(self)
	self.spinning = false
	self.face = 3 
end

function Reel:stop()
	if self.spinning then
		sfx(4)
		self.spinning = false
		self.face = flr(rnd(8)) + 1 
	end
end

function Reel:update()
	if self.spinning then
		for f in all(self.faces) do 
			f:update()
		end
	end
end

function Reel:draw()
	if not self.spinning then
		spr(self.face, self.x+1, self.y+1)
	else
		for f in all(self.faces) do 
			f:draw()
		end
	end
	
	spr(bg_spr, self.x, self.y)
end

function set_upfaces(reel)
	local start_y = reel.y +1
	for i=1, 8 do
		local f = Face(reel, i, start_y -(i - 1) * 16)
		add(reel.faces, f)
	end
end

function Reel:spin()
	self.spinning = true
end
:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9InN1Z2Fydm9pZCIsYmJzX2lkPSJfZGV2MjY3NiIsY3JlYXRlZD0i
MjAyNS0wNC0xOSAxNDo1MjoxNyIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQw
ZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwZDBk
MGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAxMDcwNzA2MDYwNjA2MDYwNjA2MDYwNjA3MDcwNzAx
MDEwNzA3MDYwNjA2MDYwNjA2MDYwNjA2MDcwNzA2MDEwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIpLGxvd2NvbF9p
Y29uPXRydWUsbW9kaWZpZWQ9IjIwMjUtMDUtMDMgMDE6MzU6MDIiLG5vdGVzPSIiLHJ1bnRpbWU9
MTcsc2FuZGJveD1mYWxzZSx0aXRsZT0iU2xvdHMiLHZlcnNpb249IiIsd29ya3NwYWNlcz17e2xv
Y2F0aW9uPSJtYWluLmx1YSMxMiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iaHVkLmx1
YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9p
bmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlv
bj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0=
:: [eoc]
