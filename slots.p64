picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NC0yMiAwMDo0OTowOSIscmV2aXNpb249MTY0MF1dbHo0AFgDAADpNAAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMt5PTAsem9vbT04fSw_AP8TGBPA
IwAjgAMqI4BKI1BqI0CKE0CKEzCaUHpwenBasCrwGFIAHf8SElgAODBoDxhIIGgOSCBYDlggyCDI
QJhQmGB4gFigOLAYUwAf-w8HKbA5sAkgCYB5cIlQmVCZUKlAqTC5MClgGUCp8CJOAB3wJxZDoAMv
GxNgMz4TQDNOAw4DMAMuAy4TDhMgAy4DDiMuAyADHjNOAzAjHhMuE1ADLkNgAz4DkAQAfxMeE6Az
8AZxAB3wCiHK8AM3YBcgBxAHIBcQJxAHABcgFxAHAAcKAFEQJxAnEA4AYQAHEBcwNwgAQicgFyAg
AG8H8AO68BJyAB3wFSOcQAwvHAweDC4cEAxOHE4MIAw_DE4MMAw_DD4MUAwuDD4MYB4A-wgMcAwe
DB4MkAwODA4MsBwODLAs0AzwCG8AHf89B08bcD47LiAuiw4gDmtHEB47NygHEA4rJ0gXDgAOGxdY
FwsOAA4LF1gXGw4ADhdIJysOAA4HOCdLDhAHCDdbHhAnex4QLls_QH7wBesAHv8MCHAYQKhAqEAI
UCjAGMAYwCiwKKA4oDiwKPAZTAAZjxISBPYD8AAWAwAZL-YDYgAZtAgIBPADFsAGEAYwBAAvNhBB
AB0-CxZAQQAqZhA-EDBOIAIAHz5BABrvBAQEABkACRoZGgkAGQCrAR0f8DEASvEDCgoEIDEwET8Q
ERABXgEAAX4RAgDPAQABXgEQET4RMDEgTwALLzE1gQAeDzEA-----------Qw0VABPA49i5gBvAs
BgUAUED-HCJACABPDvAgDgkAKBH_RgAv8CwFAFrwAgjPEfAHBmAG4F0gDaANIF3QDABRDRAKAA0Q
AFINAAoQDRQAAAoAAhQAAB4AAhQAEzoSAB86JAAID0wAAAdsAFrwCM3wB5MABQUAooD9GZAGYAaw
DfA4APAAoA3wEg3ABmAGkA3wFA2wIgBQDfAWDaAJAEn-EBigPQAPBQAPP-YuMPoBCx82KwIeDzEA
------------------------------------------------bFBtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yMiAwMDo0OTowOSJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NC0yMiAwMDo0OTowOSIscmV2aXNpb249MTUzM11dbHo0AGsAAABbEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgA0nk9MCx0aWxlX2g9MTYKABB3CgCwem9vbT0wLjI1fX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yMiAwMDo0OTowOSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NC0yMiAwMDo0OTowOSIscmV2aXNpb249MTUzNF1dbHo0AB8BAACTCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA----
--_9H-8BAKzzDcgPQAAPEEAPJw--Dyn--y0ADQD9LQ4NDv0t8HAbAPUJMA8yDzQNDzcPNQ85-Skg
DSD9KS4NLv0pIQDxCDQPOQ81DzsPNw88Dz4PO-0ocP0ofv0oIADlCAACIA8o-S8A-S8H-S8zAIM5
-S8B-S8PEBMAQQog-bJLASBMAx8AKf2wWAFMBAMABBQADwEA-8ZQ-----7g=
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yMiAwMDo0OTowOSJdXQ==
:: classic.lua
--[[pod_format="raw",created="2025-04-13 15:00:11",modified="2025-04-18 03:30:20",revision=110]]
--
-- classic
--
-- Copyright (c) 2014, rxi
--
-- This module is free software; you can redistribute it and/or modify it under
-- the terms of the MIT license. See LICENSE for details.
--


Object = {}
Object.__index = Object


function Object:new()
end


function Object:extend()
  local cls = {}
  for k, v in pairs(self) do
    if k:find("__") == 1 then
      cls[k] = v
    end
  end
  cls.__index = cls
  cls.super = self
  setmetatable(cls, self)
  return cls
end


function Object:implement(...)
  for _, cls in pairs({...}) do
    for k, v in pairs(cls) do
      if self[k] == nil and type(v) == "function" then
        self[k] = v
      end
    end
  end
end


function Object:is(T)
  local mt = getmetatable(self)
  while mt do
    if mt == T then
      return true
    end
    mt = getmetatable(mt)
  end
  return false
end


function Object:__tostring()
  return "Object"
end


function Object:__call(...)
  local obj = setmetatable({}, self)
  obj:new(...)
  return obj
end


:: clock.lua
--[[pod_format="raw",created="2025-04-20 14:09:58",modified="2025-04-22 00:49:09",revision=720]]
Trigger = Object:extend()

function Trigger:new(callback, seconds, is_repeat)
    self.callback = nil
    self.sec = nil
    self.is_repeat = nil
end

-----------------------

Clock = Object:extend()

function Clock:new()
    self.seconds = 0
    self.t = 0
    self.is_running = false
    self.triggers = nil
end

function Clock:add_trigger(callback, seconds, is_repeat)
    local _trig = Trigger(callback, seconds, is_repeat)
    if self.triggers == nil then
        self.triggers = {}
    end
    table.insert(self.triggers, _trig)
end

function Clock:tick()
    self.seconds = self.seconds + 1
    self.t = 0
end

function Clock:update()
    if self.is_running then
        self.t = self.t + 1
        if self.t >= 60 then
            self:tick()
        end
    end
end

function Clock:stop()
	self:restart()
    self.is_running = false
end

function Clock:start()
    self.is_running = true
end

function Clock:restart()
    self.t = 0
    self.seconds = 0
end
:: coin.lua
--[[pod_format="raw",created="2025-04-22 00:25:21",modified="2025-04-22 00:49:09",revision=112]]



Coin = Object:extend()



function randi_rang(l, h)
    return flr(rnd(h - l + 1)) + l
end



function Coin:new(x, y)
	self.img = 13
	self.x = x
	self.y = y 
end

function Coin:draw()
	spr(self.img, self.x, self.y)
end

function Coin:update()
	self.y += 0.5
	if self.y >= 85 then
	end 
end

function draw_coins()
	foreach(all_coins, function(obj) obj:draw() end )
end

function update_coins()
	foreach(all_coins, function(obj) obj:update() end )
end

function spawn_coin(num)
	for i=1, num+1 do
		local x = randi_rang(30, 62)
		local y = 64
		add(all_coins, Coin(x,y))
	end
end

all_coins = {
	--Coin(78, 42)
	Coin(50, 65),
	Coin(55, 65),
	Coin(62, 65),
	Coin(40, 65),
	Coin(30, 85),
}



:: face.lua
--[[pod_format="raw",created="2025-04-19 16:03:43",modified="2025-04-22 00:49:09",revision=1446]]
Face = Object:extend()

local FACE_STR = {
	{"lemon",10},
	{"heart",8},
	{"bell",9},
	{"clover",27},
	{"bar",10},
	{"dimond",28},
	{"melon",11},
	{"seven",8},
}

top = -60
bottom = 68

function Face:new(reel, img, y)
	self.parent = reel
	self.img = img
	self.x = reel.x + 1
	self.y = y
	self.speed = 4
end

function Face:draw()
	if self.y >= 5 and self.y <= 35 then
		spr(self.img, self.x, self.y)
	end
end

function Face:update()
	self.y += self.speed
	if self.y >= bottom then
		self.y = top
	end
end

function get_face_string(num)
	return tostr(num), FACE_STR[num][2]
	--return FACE_STR[num][1], FACE_STR[num][2]
end
:: flux.lua
--[[pod_format="raw",created="2025-04-19 17:37:55",modified="2025-04-19 21:10:06",revision=216]]
--
-- flux
--
-- Copyright (c) 2016 rxi
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

local flux = { _version = "0.1.5" }
flux.__index = flux

flux.tweens = {}
flux.easing = { linear = function(p) return p end }

local easing = {
  quad    = "p * p",
  cubic   = "p * p * p",
  quart   = "p * p * p * p",
  quint   = "p * p * p * p * p",
  expo    = "2 ^ (10 * (p - 1))",
  sine    = "-math.cos(p * (math.pi * .5)) + 1",
  --circ    = "-(math.sqrt(1 - (p * p)) - 1)",
  back    = "p * p * (2.7 * p - 1.7)",
  elastic = "-(2^(10 * (p - 1)) * math.sin((p - 1.075) * (math.pi * 2) / .3))"
}

local makefunc = function(str, expr)
  local load = loadstring or load
  return load("return function(p) " .. str:gsub("%$e", expr) .. " end")()
end

for k, v in pairs(easing) do
  flux.easing[k .. "in"] = makefunc("return $e", v)
  flux.easing[k .. "out"] = makefunc([[
    p = 1 - p
    return 1 - ($e)
  ]], v)
  flux.easing[k .. "inout"] = makefunc([[
    p = p * 2
    if p < 1 then
      return .5 * ($e)
    else
      p = 2 - p
      return .5 * (1 - ($e)) + .5
    end
  ]], v)
end



local tween = {}
tween.__index = tween

local function makefsetter(field)
  return function(self, x)
    local mt = getmetatable(x)
    if type(x) ~= "function" and not (mt and mt.__call) then
      error("expected function or callable", 2)
    end
    local old = self[field]
    self[field] = old and function() old() x() end or x
    return self
  end
end

local function makesetter(field, checkfn, errmsg)
  return function(self, x)
    if checkfn and not checkfn(x) then
      error(errmsg:gsub("%$x", tostring(x)), 2)
    end
    self[field] = x
    return self
  end
end

tween.ease  = makesetter("_ease",
                         function(x) return flux.easing[x] end,
                         "bad easing type '$x'")
tween.delay = makesetter("_delay",
                         function(x) return type(x) == "number" end,
                         "bad delay time; expected number")
tween.onstart     = makefsetter("_onstart")
tween.onupdate    = makefsetter("_onupdate")
tween.oncomplete  = makefsetter("_oncomplete")


function tween.new(obj, dur, vars)
  local self = setmetatable({}, tween)
  self.obj = obj
  self.rate = dur > 0 and 1 / dur or 0
  self.progress = dur > 0 and 0 or 1
  self._delay = 0
  self._ease = "quadout"
  self.vars = {}
  for k, v in pairs(vars) do
    if type(v) ~= "number" then
      error("bad value for key '" .. k .. "'; expected number")
    end
    self.vars[k] = v
  end
  return self
end


function tween:init()
  for k, v in pairs(self.vars) do
    local x = self.obj[k]
    if type(x) ~= "number" then
      error("bad value on object key '" .. k .. "'; expected number")
    end
    self.vars[k] = { start = x, diff = v - x }
  end
  self.inited = true
end


function tween:after(...)
  local t
  if select("#", ...) == 2 then
    t = tween.new(self.obj, ...)
  else
    t = tween.new(...)
  end
  t.parent = self.parent
  self:oncomplete(function() flux.f_add(self.parent, t) end)
  return t
end


function tween:stop()
  flux.remove(self.parent, self)
end



function flux.group()
  return setmetatable({}, flux)
end


function flux:to(obj, dur, vars)
  return flux.f_add(self, tween.new(obj, dur, vars))
end


function flux:update(deltatime)
  for i = #self, 1, -1 do
    local t = self[i]
    if t._delay > 0 then
      t._delay = t._delay - deltatime
    else
      if not t.inited then
        flux.clear(self, t.obj, t.vars)
        t:init()
      end
      if t._onstart then
        t._onstart()
        t._onstart = nil
      end
      t.progress = t.progress + t.rate * deltatime
      local p = t.progress
      local x = p >= 1 and 1 or flux.easing[t._ease](p)
      for k, v in pairs(t.vars) do
        t.obj[k] = v.start + x * v.diff
      end
      if t._onupdate then t._onupdate() end
      if p >= 1 then
        flux.remove(self, i)
        if t._oncomplete then t._oncomplete() end
      end
    end
  end
end


function flux:clear(obj, vars)
  for t in pairs(self[obj]) do
    if t.inited then
      for k in pairs(vars) do t.vars[k] = nil end
    end
  end
end


function flux:f_add(tween)
  -- Add to object table, create table if it does not exist
  local obj = tween.obj
  self[obj] = self[obj] or {}
  self[obj][tween] = true
  -- Add to array
  table.insert(self, tween)
  tween.parent = self
  return tween
end


function flux:remove(x)
  if type(x) == "number" then
    -- Remove from object table, destroy table if it is empty
    local obj = self[x].obj
    self[obj][self[x]] = nil
    if not next(self[obj]) then self[obj] = nil end
    -- Remove from array
    self[x] = self[#self]
    return table.remove(self)
  end
  for i, v in ipairs(self) do
    if v == x then
      return flux.remove(self, i)
    end
  end
end


function get_flux()
	local your_flux = {
	  to      = function(...) return flux.to(flux.tweens, ...) end,
	  update  = function(...) return flux.update(flux.tweens, ...) end,
	  remove  = function(...) return flux.remove(flux.tweens, ...) end,
	}
	setmetatable(your_flux, flux)
	return your_flux

end


:: handle.lua
--[[pod_format="raw",created="2025-04-19 17:45:36",modified="2025-04-22 00:49:09",revision=1233]]

handle = {
	x=78,
	y=20,
	radius = 4,
	draw=function(self)
		rect(self.x+4, self.y+5, self.x+5, 45, 13)
		spr(16, self.x, self.y)
	end,
	update=function(self)
	end,
	pull=function(self)
		if self.y == 20 and cash >= curr_bet then
			--cash:update_val(-cost)
			cash = mid(0, cash - curr_bet, 999999)
			flux.to(self, 0.6, { y = 60}):ease("quadin"):oncomplete(
				function()
					start_reels()
					flux.to(self, 1, {y = 20}):ease("backin")
				end
			)
		end
	end,
}
:: light.lua
--[[pod_format="raw",created="2025-04-21 23:26:22",modified="2025-04-22 00:49:09",revision=241]]



Light = Object:extend()

local light_y = 7

function Light:new(x)
	self.img = 10
	self.x = x
	--self.y = y
	self.on = false 
end

function Light:draw()
	spr(self.img, self.x, light_y)
end

function Light:update()
 
end

function draw_lights()
	foreach(all_lights, function(obj) obj:draw() end )
end

all_lights = {
	Light(21),
	Light(29),
	Light(37),
	Light(45),
	Light(53),
	Light(61),
	Light(69),
}

:: main.lua
--[[pod_format="raw",created="2025-04-19 14:51:36",modified="2025-04-22 00:49:09",revision=2228]]

include "flux.lua"
include "classic.lua"
include "light.lua"
include "coin.lua"
include "clock.lua"
include "face.lua"
include "reel.lua"
include "handle.lua"

W, H = 200, 200


flux = get_flux()
mx, my, mb = nil, nil, nil
m_delay = 0
curr_bet = 5

local last_time = time()
local dt = 0
local reel_timer = 0
local reels_started = false
local key_delay = 0

local clock_pull = Clock()
local clock_stop_1 = Clock()
local clock_stop_2 = Clock()
local clock_stop_3 = Clock()

local clocks = {}
add(clocks, clock_pull)
add(clocks, clock_stop_1)
add(clocks, clock_stop_2)
add(clocks, clock_stop_3)

local results = {0,0,0}
local payout=0

local PAYOUTS_3 = {
	100,200,300,400,500,600,700,800
}

local PAYOUTS_2 = {
	10,20,30,40,50,60,70,80
}


auto_mode = false
has_spun = false
local show_payout = false

cost = 5
cash = 200

--{
--	value = 123, 
--	new_val = 123,
--	tic=0,
--	update_val=function(self,v)
--		self.new_val = self.value + v
--	end,
--	update=function(self)
--		self.tic +=1
--		if self.tic >= 1 then
--			if self.value < self.new_val then
--				self.value += 1
--			elseif self.value > self.new_val then
--				self.value -= 1
--			end
--			self.tic = 0
--		end
--	end,
--	
--	}

canvas = {}
canvas = userdata("u8", W, H)

reels = {}

function _init()
	poke(0x5f5c, 20)
	poke(0x5f5d, 20)
	window {
		width      = 200,
		height     = 200,
		resizeable = false,
		--title = "$" .. tostr(cash),
		title      = "Slots",
	}
	
	reel_1 = Reel(20, 30, {x=10, y=40})
	reel_2 = Reel(40, 30, {x=33, y=40})
	reel_3 = Reel(60, 30, {x=55, y=40})
	

	--print(reel_1.face_str, 20, 90, 7)
	--print(reel_2.face_str, 65, 90, 7)
	--print(reel_3.face_str, 110, 90, 7)
	
	add(reels, reel_1)
	add(reels, reel_2)
	add(reels, reel_3)
	

end

function draw_obj()
	return function(obj) obj:draw() end
end

function _update()
	
	if not auto_mode then
		if btnp(3) and not are_reels_spinning() then
			--handle:pull()
			pull_handle()
		end
	end
	
	if _keyp("a") then
		toggle_auto_mode()
	end
	
	if btnp(1) then
		curr_bet = mid(5, curr_bet + 5, 80)
	elseif btnp(0) then
		curr_bet = mid(5, curr_bet - 5, 80)
	end
	
	if btnp(4) then
		spawn_coin(10)
	end

	mx,my,mb = mouse()
	mx = flr(mx/2)
	my = flr(my/2)
	update_dt()
  	flux.update(dt)
  	update_coins()

	foreach(reels, function(obj) obj:update() end )
	
	
	if reels_started then
		reel_timer += 1
		for t in ipairs(reel_timers) do
			if not t.triggered and totalTime >= t.delay then
				t.reel.spinning = true
				t.triggered = true
			end
		end
	end

	foreach(clocks, function(obj) obj:update() end )
	
	if clock_pull.seconds >= 5 then
		clock_pull.seconds = 0
		pull_handle()
	end
	
	if clock_stop_1.seconds == 2 then
		clock_stop_1:stop()
		stop_reel(1)
	end
	if clock_stop_2.seconds == 3 then
		clock_stop_2:stop()
		stop_reel(2)
	end
	if clock_stop_3.seconds == 4 then
		clock_stop_3:stop()
		stop_reel(3)
	end
	
	if not are_reels_spinning() then
		--sfx(-1,2)
	end
	
end

function _draw()
	cls()
	
	set_draw_target(canvas)
	cls()
	
	spr(64, 15, 15)
	draw_lights()
	draw_coins()
	
	clip(20, 30, 62, 18)
	reel_1:draw()
	reel_2:draw()
	reel_3:draw()
	clip()
	
	spr(12, 78, 42)

	handle:draw()
	print("$", 2, 91, 7)
	print(pad_zeros(cash, 6), 8, 92, 7)
	
	if auto_mode then
		print("AUTO", 1, 92, 7)
	end
	
	print(pad_zeros(curr_bet, 2), 45, 51, 7)
	
	
	
	
	--set_draw_target()
	--sspr(canvas, 0, 0, 100, 100, 0, 0, 100, 100)

 	--print("mem: " .. stat(0) .. "kb", 10, 0, 8)
   --print("cpu: " .. stat(1) * 100 .. "%", 10, 8, 8)
	
	
	if show_payout then
		print("Payout  ".. tostr(payout), 9, 55, 7)
		print("$", 43, 54, 7)
	end
	
	set_draw_target()
	sspr(canvas, 0, 0, 100, 100, 0, 0, 200, 200)
	
	set_draw_target()
	

end

function start_reels()
	sfx(3, 2)
	results = {0,0,0}
	payout = 0
	show_payout = false
	has_spun = true
	foreach(reels, function(obj) obj:spin() end ) 
end

function stop_reel(num)
	if num == 1 then
		reel_1:stop()
		results[1] = reel_1.face
	elseif num == 2 then
		reel_2:stop()
		results[2] = reel_2.face
	elseif num == 3 then
		reel_3:stop()
		results[3] = reel_3.face
	end
	if not are_reels_spinning() and has_spun then
		sfx(-1,2)
		has_spun = false
		show_payout = true
		payout = get_payout(results)
		--cash:update_val(pay)
		cash = mid(0, cash + payout, 999999)
		-- -- window{title = "$" .. tostr(cash)}
	end
end

function update_dt()
	local t = time()
  	dt = t - last_time
  	last_time = t
end

function pad_zeros(num, zeros)
	return string.format("%0".. zeros .. "d", num)
end

function toggle_auto_mode()
	auto_mode = not auto_mode
	if auto_mode then
		if not are_reels_spinning() then
			pull_handle()
		else
			start_reel_clocks()
		end
		clock_pull:start()
	end
end

function are_reels_spinning()
	return reel_1.spinning or reel_2.spinning or reel_3.spinning
end

function pull_handle()
	handle:pull()
	start_reel_clocks()
end

function start_reel_clocks()
	clock_stop_1:start()
	clock_stop_2:start()
	clock_stop_3:start()
end

function _keyp(k)
    if keyp(k) and key_delay <= 0 then
        key_delay = 20
        return true
    else
        key_delay = mid(0, key_delay - 1, 21)
    end
end

function get_payout(r)
	--TODO: Figure out better payout math
	if r[1] == 0 or r[2] == 0 or r[3] == 0 then
		return 0
	end
	if r[1] == r [2] and r[2] == r[3] then
		sfx(2)
		return PAYOUTS_3[r[1]]
	elseif r[1] == r[2] or r[2] == r[3] or r[1] == r[3] then
		local match = r[1] == r[2] and r[1] or r[2] == r[3] and r[2] or r[1]
		sfx(1)
		return PAYOUTS_2[match] or 0
	else
		sfx(0)
		return 0
	end
end

function update_player_cash()
	store("slots_cash.pod", cash)
end
:: reel.lua
--[[pod_format="raw",created="2025-04-19 16:25:05",modified="2025-04-22 00:49:09",revision=1428]]

Reel = Object:extend()

local bg_spr = 9

function Reel:new(x, y, str_pos)
	self.img = 1
	self.x = x
	self.y = y
	self.reel_y = 0 
	self.faces = {}
	set_upfaces(self)
	self.spinning = false
	self.face_str = ""
	self.face_str_pos = str_pos
	self.str_col = 7
	self.face = 3 
end

function Reel:stop()
	if self.spinning then
		sfx(4)
		self.spinning = false
		self.face = flr(rnd(8)) + 1 
		self.face_str, self.str_col = get_face_string(self.face)
	end
end

function Reel:update()
	if self.spinning then
		for f in all(self.faces) do 
			f:update()
		end
	end
end

function Reel:draw()
	if not self.spinning then
		spr(self.face, self.x+1, self.y+1)
	else
		for f in all(self.faces) do 
			f:draw()
		end
	end
	
	spr(bg_spr, self.x, self.y)
end

function Reel:draw_reel_str()
	print(self.face_str, self.face_str_pos.x, self.face_str_pos.y, self.str_col)
end

function set_upfaces(reel)
	local start_y = reel.y +1
	for i=1, 8 do
		local f = Face(reel, i, start_y -(i - 1) * 16)
		add(reel.faces, f)
	end
end

function Reel:spin()
	self.spinning = true
	self.face_str = ""
end
:: slot.lua
--[[pod_format="raw",created="2025-04-19 15:58:28",modified="2025-04-19 16:25:00",revision=96]]

Slot = Object:extend()

local bg_spr = 8

function Slot:new(x, y)
	self.img = 1
	self.x = x
	self.y = y
	self.reel_y = 0 
	self.faces = {
		{ 
			y = 0,
			img = 0
		}
	}
end

function Slot:draw()
	spr(bg_spr, self.x, self.y)
	spr(self.img, self.x+1, self.y+1)
end
:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9InN1Z2Fydm9pZCIsYmJzX2lkPSJfZGV2MjY3NiIsY3JlYXRlZD0i
MjAyNS0wNC0xOSAxNDo1MjoxNyIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQw
ZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwZDBk
MGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAxMDcwNzA2MDYwNjA2MDYwNjA2MDYwNjA3MDcwNzAx
MDEwNzA3MDYwNjA2MDYwNjA2MDYwNjA2MDcwNzA2MDEwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDEwMTAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIpLG1vZGlmaWVk
PSIyMDI1LTA0LTIyIDAwOjQ5OjA5Iixub3Rlcz0iIixydW50aW1lPTE2LHNhbmRib3g9ZmFsc2Us
dGl0bGU9IlNsb3RzIix2ZXJzaW9uPSIiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEj
MTMyIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJyZWVsLmx1YSMyIix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJmYWNlLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0
aW9uPSJoYW5kbGUubHVhIzE1Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJjbG9jay5s
dWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ibGlnaHQubHVhIzgiLHdvcmtzcGFj
ZV9pbmRleD0xfSx7bG9jYXRpb249ImNvaW4ubHVhIzQwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1h
cCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH19XV0=
:: [eoc]
