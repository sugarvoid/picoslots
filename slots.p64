picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NC0yMCAxNTo1NDowNCIscmV2aXNpb249OTkxXV1sejQAZwIAAOcyAADzIXtbMF09e2JtcD1weHUA
QyAQEATwVgcQB8AX0BfABxAH8FYsZmxhZ3M9MCxwYW5feAgAy3k9MCx6b29tPTh9LD4A-xMYE8Aj
ACOAAyojgEojUGojQIoTQIoTMJpQenB6cFqwKvAYUgAd-xISWAA4MGgPGEggaA5IIFgOWCDIIMhA
mFCYYHiAWKA4sBhTAB--DwcpsDmwCSAJgHlwiVCZUJlQqUCpMLkwKWAZQKnwIk4AHfAnFkOgAy8b
E2AzPhNAM04DDgMwAy4DLhMOEyADLgMOIy4DIAMeM04DMCMeEy4TUAMuQ2ADPgOQBAB-Ex4ToDPw
BnEAHfAKIcrwAzdgFyAHEAcgFxAnEAcAFyAXEAcABwoAURAnECcQDgBhAAcQFzA3CABCJyAXICAA
bwfwA7rwEnIAHfAVI5xADC8cDB4MLhwQDE4cTgwgDD4MTgwwDD4MPgxQDC4MPgxgHgD-CAxwDB4M
HgyQDA4MDgywHA4MsCzQDPAIbwAd-z0HTxtwPjsuIC6LDiAOa0cQHjs3KAcQDisnSBcOAA4bF1gX
Cw4ADgsXWBcbDgAOF0gnKw4ADgc4J0sOEAcIN1seECd7HhAuWz5AfvAF6wAe-wwIcBhAqECoQAhQ
KMAYwBjAKLAooDigOLAo8BlMABmPEhIE9gPwABYDABkv9gOuAB0f8DEA-w-xAwoKBCA9MB0-Fx0Q
DV4NAA1_HQIAzw0ADV4NEB0_HTA9IE8ACy8xNYEAHg8xAP------------------------------
-----------------------------6VQbT04fX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yMCAxNTo1NDowNSJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NC0yMCAxNTo1NDowNCIscmV2aXNpb249OTUzXV1sejQAawAAAFsQAADwCHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDMyAwAvIjABAP--------------------vxCCIpLGhpZGRlbj1mYWxzZSxwYW5feD0w
CADSeT0wLHRpbGVfaD0xNgoAEHcKALB6b29tPTAuMjV9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yMCAxNTo1NDowNSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUxOjM2Iixtb2RpZmllZD0iMjAyNS0w
NC0yMCAxNTo1NDowNCIscmV2aXNpb249OTUxXV1sejQAoAAAAAsKAAD-MHB4dQADKAAABAAED0AQ
Ag4AAaABIAKgDgAPEAAN8MoBAgNADw_QBAUGB0AMkAgJCgtADJAPDA8NDw4MQAzw-wEA6-8nqgEQ
Bg8gEAEgASAB8AACEAIOEAEgDyEgATAPQPDDDygP--DGD-gKD-8PgA-3Dw0B8AkBEAYOMAD-----
-70f-wEArM-ID0AADxBA--_w8P8BAP-qUP----8p
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yMCAxNTo1NDowNSJdXQ==
:: classic.lua
--[[pod_format="raw",created="2025-04-13 15:00:11",modified="2025-04-18 03:30:20",revision=110]]
--
-- classic
--
-- Copyright (c) 2014, rxi
--
-- This module is free software; you can redistribute it and/or modify it under
-- the terms of the MIT license. See LICENSE for details.
--


Object = {}
Object.__index = Object


function Object:new()
end


function Object:extend()
  local cls = {}
  for k, v in pairs(self) do
    if k:find("__") == 1 then
      cls[k] = v
    end
  end
  cls.__index = cls
  cls.super = self
  setmetatable(cls, self)
  return cls
end


function Object:implement(...)
  for _, cls in pairs({...}) do
    for k, v in pairs(cls) do
      if self[k] == nil and type(v) == "function" then
        self[k] = v
      end
    end
  end
end


function Object:is(T)
  local mt = getmetatable(self)
  while mt do
    if mt == T then
      return true
    end
    mt = getmetatable(mt)
  end
  return false
end


function Object:__tostring()
  return "Object"
end


function Object:__call(...)
  local obj = setmetatable({}, self)
  obj:new(...)
  return obj
end


:: clock.lua
--[[pod_format="raw",created="2025-04-20 14:09:58",modified="2025-04-20 15:54:04",revision=141]]
Trigger = Object:extend()

function Trigger:new(callback, seconds, is_repeat)
    self.callback = nil
    self.sec = nil
    self.is_repeat = nil
end

-----------------------

Clock = Object:extend()

function Clock:new()
    self.seconds = 0
    self.t = 0
    self.is_running = false
    self.triggers = nil
end

function Clock:add_trigger(callback, seconds, is_repeat)
    local _trig = Trigger(callback, seconds, is_repeat)
    if self.triggers == nil then
        self.triggers = {}
    end
    table.insert(self.triggers, _trig)
end

function Clock:tick()
    self.seconds = self.seconds + 1
    self.t = 0
end

function Clock:update()
    if self.is_running then
        self.t = self.t + 1
        if self.t >= 60 then
            self:tick()
        end
    end
end

function Clock:stop()
	self:restart()
    self.is_running = false
end

function Clock:start()
    self.is_running = true
end

function Clock:restart()
    self.t = 0
    self.seconds = 0
end
:: face.lua
--[[pod_format="raw",created="2025-04-19 16:03:43",modified="2025-04-20 15:54:04",revision=873]]
Face = Object:extend()

local FACE_STR = {
	{"lemon",10},
	{"heart",8},
	{"bell",9},
	{"clover",27},
	{"bar",10},
	{"dimond",28},
	{"melon",11},
	{"seven",8},
}

top = -60
bottom = 68

function Face:new(reel, img, y)
	self.parent = reel
	self.img = img
	self.x = reel.x + 1
	self.y = y
	self.speed = 4
end

function Face:draw()
	if self.y >= 5 and self.y <= 35 then
		spr(self.img, self.x, self.y)
	end
end

function Face:update()
	self.y += self.speed
	if self.y >= bottom then
		self.y = top
	end
end

function get_face_string(num)
	return FACE_STR[num][1], FACE_STR[num][2]
end
:: flux.lua
--[[pod_format="raw",created="2025-04-19 17:37:55",modified="2025-04-19 21:10:06",revision=216]]
--
-- flux
--
-- Copyright (c) 2016 rxi
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

local flux = { _version = "0.1.5" }
flux.__index = flux

flux.tweens = {}
flux.easing = { linear = function(p) return p end }

local easing = {
  quad    = "p * p",
  cubic   = "p * p * p",
  quart   = "p * p * p * p",
  quint   = "p * p * p * p * p",
  expo    = "2 ^ (10 * (p - 1))",
  sine    = "-math.cos(p * (math.pi * .5)) + 1",
  --circ    = "-(math.sqrt(1 - (p * p)) - 1)",
  back    = "p * p * (2.7 * p - 1.7)",
  elastic = "-(2^(10 * (p - 1)) * math.sin((p - 1.075) * (math.pi * 2) / .3))"
}

local makefunc = function(str, expr)
  local load = loadstring or load
  return load("return function(p) " .. str:gsub("%$e", expr) .. " end")()
end

for k, v in pairs(easing) do
  flux.easing[k .. "in"] = makefunc("return $e", v)
  flux.easing[k .. "out"] = makefunc([[
    p = 1 - p
    return 1 - ($e)
  ]], v)
  flux.easing[k .. "inout"] = makefunc([[
    p = p * 2
    if p < 1 then
      return .5 * ($e)
    else
      p = 2 - p
      return .5 * (1 - ($e)) + .5
    end
  ]], v)
end



local tween = {}
tween.__index = tween

local function makefsetter(field)
  return function(self, x)
    local mt = getmetatable(x)
    if type(x) ~= "function" and not (mt and mt.__call) then
      error("expected function or callable", 2)
    end
    local old = self[field]
    self[field] = old and function() old() x() end or x
    return self
  end
end

local function makesetter(field, checkfn, errmsg)
  return function(self, x)
    if checkfn and not checkfn(x) then
      error(errmsg:gsub("%$x", tostring(x)), 2)
    end
    self[field] = x
    return self
  end
end

tween.ease  = makesetter("_ease",
                         function(x) return flux.easing[x] end,
                         "bad easing type '$x'")
tween.delay = makesetter("_delay",
                         function(x) return type(x) == "number" end,
                         "bad delay time; expected number")
tween.onstart     = makefsetter("_onstart")
tween.onupdate    = makefsetter("_onupdate")
tween.oncomplete  = makefsetter("_oncomplete")


function tween.new(obj, dur, vars)
  local self = setmetatable({}, tween)
  self.obj = obj
  self.rate = dur > 0 and 1 / dur or 0
  self.progress = dur > 0 and 0 or 1
  self._delay = 0
  self._ease = "quadout"
  self.vars = {}
  for k, v in pairs(vars) do
    if type(v) ~= "number" then
      error("bad value for key '" .. k .. "'; expected number")
    end
    self.vars[k] = v
  end
  return self
end


function tween:init()
  for k, v in pairs(self.vars) do
    local x = self.obj[k]
    if type(x) ~= "number" then
      error("bad value on object key '" .. k .. "'; expected number")
    end
    self.vars[k] = { start = x, diff = v - x }
  end
  self.inited = true
end


function tween:after(...)
  local t
  if select("#", ...) == 2 then
    t = tween.new(self.obj, ...)
  else
    t = tween.new(...)
  end
  t.parent = self.parent
  self:oncomplete(function() flux.f_add(self.parent, t) end)
  return t
end


function tween:stop()
  flux.remove(self.parent, self)
end



function flux.group()
  return setmetatable({}, flux)
end


function flux:to(obj, dur, vars)
  return flux.f_add(self, tween.new(obj, dur, vars))
end


function flux:update(deltatime)
  for i = #self, 1, -1 do
    local t = self[i]
    if t._delay > 0 then
      t._delay = t._delay - deltatime
    else
      if not t.inited then
        flux.clear(self, t.obj, t.vars)
        t:init()
      end
      if t._onstart then
        t._onstart()
        t._onstart = nil
      end
      t.progress = t.progress + t.rate * deltatime
      local p = t.progress
      local x = p >= 1 and 1 or flux.easing[t._ease](p)
      for k, v in pairs(t.vars) do
        t.obj[k] = v.start + x * v.diff
      end
      if t._onupdate then t._onupdate() end
      if p >= 1 then
        flux.remove(self, i)
        if t._oncomplete then t._oncomplete() end
      end
    end
  end
end


function flux:clear(obj, vars)
  for t in pairs(self[obj]) do
    if t.inited then
      for k in pairs(vars) do t.vars[k] = nil end
    end
  end
end


function flux:f_add(tween)
  -- Add to object table, create table if it does not exist
  local obj = tween.obj
  self[obj] = self[obj] or {}
  self[obj][tween] = true
  -- Add to array
  table.insert(self, tween)
  tween.parent = self
  return tween
end


function flux:remove(x)
  if type(x) == "number" then
    -- Remove from object table, destroy table if it is empty
    local obj = self[x].obj
    self[obj][self[x]] = nil
    if not next(self[obj]) then self[obj] = nil end
    -- Remove from array
    self[x] = self[#self]
    return table.remove(self)
  end
  for i, v in ipairs(self) do
    if v == x then
      return flux.remove(self, i)
    end
  end
end


function get_flux()
	local your_flux = {
	  to      = function(...) return flux.to(flux.tweens, ...) end,
	  update  = function(...) return flux.update(flux.tweens, ...) end,
	  remove  = function(...) return flux.remove(flux.tweens, ...) end,
	}
	setmetatable(your_flux, flux)
	return your_flux

end


:: handle.lua
--[[pod_format="raw",created="2025-04-19 17:45:36",modified="2025-04-20 15:54:04",revision=642]]

handle = {
	x=75,
	y=20,
	radius = 4,
	draw=function(self)
		rect(self.x+4, self.y+5, self.x+5, 45, 13)
		spr(16, self.x, self.y)
	end,
	update=function(self)
	end,
	pull=function(self)
		if self.y == 20 then
			cash = mid(0, cash - cost, 999999)
			flux.to(self, 0.6, { y = 60}):ease("quadin"):oncomplete(
				function()
					start_reels()
					flux.to(self, 1, {y = 20}):ease("backin")
				end
			)
		end
	end,
}
:: main.lua
--[[pod_format="raw",created="2025-04-19 14:51:36",modified="2025-04-20 15:54:04",revision=1365]]

include "flux.lua"
include "classic.lua"
include "clock.lua"
include "face.lua"
include "reel.lua"
include "handle.lua"

W, H = 100, 100


flux = get_flux()
mx, my, mb = nil, nil, nil
m_delay = 0

local last_time = time()
local dt = 0
local reel_timer = 0
local reels_started = false
local key_delay = 0

local clock_pull = Clock()
local clock_stop_1 = Clock()
local clock_stop_2 = Clock()
local clock_stop_3 = Clock()

local clocks = {}
add(clocks, clock_pull)
add(clocks, clock_stop_1)
add(clocks, clock_stop_2)
add(clocks, clock_stop_3)

results = {0,0,0}

local PAYOUTS_3 = {
	100,200,300,400,500,600,700,800
}

local PAYOUTS_2 = {
	10,20,30,40,50,60,70,80
}


auto_mode = false

cost = 5
cash = 123

canvas = {}
canvas = userdata("u8", W, H)

reels = {}

function _init()
	poke(0x5f5c, 255)
	poke(0x5f5d, 255)
	window {
		width      = 200,
		height     = 200,
		resizeable = false,
		title      = "Slots",
	}
	
	reel_1 = Reel(10, 20, {x=20, y=90})
	reel_2 = Reel(32, 20, {x=65, y=90})
	reel_3 = Reel(54, 20, {x=110, y=90})
	

	--print(reel_1.face_str, 20, 90, 7)
	--print(reel_2.face_str, 65, 90, 7)
	--print(reel_3.face_str, 110, 90, 7)
	
	add(reels, reel_1)
	add(reels, reel_2)
	add(reels, reel_3)
	

end

function draw_obj()
	return function(obj) obj:draw() end
end

function _update()
	
	if not auto_mode then
		if btnp(3) then
			handle:pull()
		end
		
		if _keyp("1") then
			stop_reel(1)
		elseif _keyp("2") then
			stop_reel(2)
		elseif _keyp("3") then
			stop_reel(3)
		end
	end
	
	
	if _keyp("a") then
		toggle_auto_mode()
	end

	mx,my,mb = mouse()
	mx = flr(mx/2)
	my = flr(my/2)
	update_dt()
  	flux.update(dt)
	--reel_1:update()
	--reel_2:update()
	--reel_3:update()
	
	foreach(reels, function(obj) obj:update() end )
	
	
	if reels_started then
		reel_timer += 1
		for t in ipairs(reel_timers) do
			if not t.triggered and totalTime >= t.delay then
				t.reel.spinning = true
				t.triggered = true
			end
		end
	end
	if not key() then
		--key_delay = 0
	end
	if auto_mode then
		foreach(clocks, function(obj) obj:update() end )
		
	
		--TODO: Clean up once I get it working
		if clock_pull.seconds >= 5 then
			clock_pull.seconds = 0
			auto_pull()
		end
		
		if clock_stop_1.seconds == 2 then
			clock_stop_1:stop()
			--reel_1:stop()
			stop_reel(1)

		end
		if clock_stop_2.seconds == 3 then
			clock_stop_2:stop()
			--reel_2:stop()
			stop_reel(2)

		end
		if clock_stop_3.seconds == 4 then
			clock_stop_3:stop()
			--reel_3:stop()
			stop_reel(3)

		end
		
	end
end

function _draw()
	cls()
	set_draw_target(canvas)
	cls()
	
	clip(10, 20, 62, 18)

	reel_1:draw()
	reel_2:draw()
	reel_3:draw()
	---rectfill(10, 19, 10+61, 19-15, 0) -- hide top
	---rectfill(10, 38, 10+61, 38+13, 0) -- hide bottom
	clip()

	handle:draw()
	print("$", 2, 89, 7)
	print(pad_zeros(cash, 6), 8, 90, 7)
	
	if auto_mode then
		print("AUTO", 40, 3, 7)
	end
	
	set_draw_target()
	sspr(canvas, 0, 0, 100, 100, 0, 0, 200, 200)
	--print("bet", 30, 80, 7)

 	--print("mem: " .. stat(0) .. "kb", 10, 0, 8)
   --print("cpu: " .. stat(1) * 100 .. "%", 10, 8, 8)
	
	--print(mx .. "," .. my, 0, 0, 7)
	
	--print(reel_1.face_str, 20, 90, 7)
	--print(reel_2.face_str, 65, 90, 7)
	--print(reel_3.face_str, 110, 90, 7)
	foreach(reels, function(obj) obj:draw_reel_str() end )
	

	print("Down:    pull", 130, 150, 7)
	print("1, 2, 3: stop", 130, 160, 7)
	print("A:       auto", 130, 170, 7)
	
	print("payout: $".. tostr(get_payout(results)), 40, 110, 7)
end

function start_reels()
	results = {0,0,0}
	foreach(reels, function(obj) obj:spin() end ) 
end

function stop_reel(num)
	if num == 1 then
		reel_1:stop()
		results[1] = reel_1.face
		--reel_1:check_faces()
	elseif num == 2 then
		reel_2:stop()
		results[2] = reel_2.face
		--reel_2.spinning = false
		--reel_2:check_faces()
	elseif num == 3 then
		reel_3:stop()
		results[3] = reel_3.face
		--reel_3.spinning = false
		--reel_3:check_faces()
	end
	if not are_reels_spinning() then
		notify("check payout")
		local pay = get_payout(results)
		cash += pay
	end
end

function update_dt()
	local t = time()
  	dt = t - last_time
  	last_time = t
end

function pad_zeros(num, zeros)
	return string.format("%0".. zeros .. "d", num)
end

function toggle_auto_mode()
	auto_mode = not auto_mode
	if auto_mode then
		if not are_reels_spinning() then
			auto_pull()
		end
		clock_pull:start()
	end
end

function are_reels_spinning()
	return reel_1.spinning or reel_2.spinning or reel_3.spinning
end

function auto_pull() 
	handle:pull()
	clock_stop_1:start()-- = Clock()
	clock_stop_2:start()-- = Clock()
	clock_stop_3:start()-- = Clock()
end

function _keyp(k)
    if keyp(k) and key_delay <= 0 then
        key_delay = 20
        return true
    else
        key_delay = mid(0, key_delay - 1, 21)
    end
end

function get_payout(r)
	if r[1] == 0 or r[2] == 0 or r[3] == 0 then
		return 0
	end
	if r[1] == r [2] and r[2] == r[3] then
		return PAYOUTS_3[r[1]]
	elseif r[1] == r[2] or r[2] == r[3] or r[1] == r[3] then
		local match = r[1] == r[2] and r[1] or r[2] == r[3] and r[2] or r[1]
		return PAYOUTS_2[match] or 0
	else
		return 0
	end
end
:: reel.lua
--[[pod_format="raw",created="2025-04-19 16:25:05",modified="2025-04-20 15:54:04",revision=842]]

Reel = Object:extend()

local bg_spr = 9

function Reel:new(x, y, str_pos)
	self.img = 1
	self.x = x
	self.y = y
	self.reel_y = 0 
	self.faces = {}
	set_upfaces(self)
	self.spinning = false
	self.face_str = ""
	self.face_str_pos = str_pos
	self.str_col = 7
	self.face = 3 
end

function Reel:stop()
	self.spinning = false
	self.face = flr(rnd(8)) + 1 
	self.face_str, self.str_col = get_face_string(self.face)
end

function Reel:update()
	if self.spinning then
		for f in all(self.faces) do 
			f:update()
		end
	end
end

function Reel:draw()
	if not self.spinning then
		spr(self.face, self.x+1, self.y+1)
	else
		for f in all(self.faces) do 
			f:draw()
		end
	end
	
	spr(bg_spr, self.x, self.y)
end

function Reel:draw_reel_str()
	print(self.face_str, self.face_str_pos.x, self.face_str_pos.y, self.str_col)
end

function set_upfaces(reel)
	local start_y = reel.y +1
	for i=1, 8 do
		local f = Face(reel, i, start_y -(i - 1) * 16)
		add(reel.faces, f)
	end
end

function Reel:spin()
	self.spinning = true
	self.face_str = ""
end
:: slot.lua
--[[pod_format="raw",created="2025-04-19 15:58:28",modified="2025-04-19 16:25:00",revision=96]]

Slot = Object:extend()

local bg_spr = 8

function Slot:new(x, y)
	self.img = 1
	self.x = x
	self.y = y
	self.reel_y = 0 
	self.faces = {
		{ 
			y = 0,
			img = 0
		}
	}
end

function Slot:draw()
	spr(bg_spr, self.x, self.y)
	spr(self.img, self.x+1, self.y+1)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE5IDE0OjUyOjE3Iixtb2RpZmllZD0iMjAyNS0w
NC0yMCAxNTo1NDowNSIscnVudGltZT0xNix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzE4OCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0icmVlbC5sdWEjMTMiLHdvcmtzcGFj
ZV9pbmRleD0xfSx7bG9jYXRpb249ImZhY2UubHVhIzIxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJoYW5kbGUubHVhIzgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImNsb2Nr
Lmx1YSM0MyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3Bh
Y2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9j
YXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1d
:: [eoc]
